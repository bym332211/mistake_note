import os<CR><NL>import uuid<CR><NL>import io<CR><NL>import logging<CR><NL>from typing import Optional<CR><NL>from datetime import datetime<CR><NL>from fastapi import FastAPI, UploadFile, File, HTTPException<CR><NL>from fastapi.staticfiles import StaticFiles<CR><NL>from fastapi.middleware.cors import CORSMiddleware<CR><NL>from dotenv import load_dotenv<CR><NL>import json<CR><NL>import sys<CR><NL>import os<CR><NL><CR><NL># æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°Pythonè·¯å¾„ï¼Œä»¥ä¾¿å¯¼å…¥æ•°æ®åº“é…ç½®<CR><NL>sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))<CR><NL><CR><NL>try:<CR><NL>    from db.database_config import get_db, save_mistake_record, MistakeRecord, MistakeAnalysis, MistakePractice<CR><NL>    DATABASE_AVAILABLE = True<CR><NL>except ImportError as e:<CR><NL>    logger = logging.getLogger('coze_api')<CR><NL>    logger.warning(f"æ•°æ®åº“é…ç½®å¯¼å…¥å¤±è´¥: {e}ï¼Œå°†ä¸ä¼šä¿å­˜æ•°æ®åˆ°æ•°æ®åº“")<CR><NL>    DATABASE_AVAILABLE = False<CR><NL><CR><NL><CR><NL><CR><NL># é…ç½®æ—¥å¿—<CR><NL><CR><NL>logging.basicConfig(<CR><NL><CR><NL>    level=logging.INFO,<CR><NL><CR><NL>    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',<CR><NL><CR><NL>    handlers=[<CR><NL><CR><NL>        logging.FileHandler('coze_api.log', encoding='utf-8'),<CR><NL><CR><NL>        logging.StreamHandler()<CR><NL><CR><NL>    ]<CR><NL><CR><NL>)<CR><NL><CR><NL>logger = logging.getLogger('coze_api')<CR><NL><CR><NL><CR><NL><CR><NL>load_dotenv()<CR><NL><CR><NL><CR><NL><CR><NL>app = FastAPI()<CR><NL><CR><NL><CR><NL><CR><NL># æ·»åŠ CORSä¸­é—´ä»¶<CR><NL><CR><NL>app.add_middleware(<CR><NL><CR><NL>    CORSMiddleware,<CR><NL><CR><NL>    allow_origins=["*"],  # å…è®¸æ‰€æœ‰æ¥æºï¼Œç”Ÿäº§ç¯å¢ƒåº”è¯¥é™åˆ¶<CR><NL><CR><NL>    allow_credentials=True,<CR><NL><CR><NL>    allow_methods=["*"],  # å…è®¸æ‰€æœ‰æ–¹æ³•<CR><NL><CR><NL>    allow_headers=["*"],  # å…è®¸æ‰€æœ‰å¤´<CR><NL><CR><NL>)<CR><NL><CR><NL><CR><NL><CR><NL># æŒ‚è½½åª’ä½“ç›®å½•ä¸ºé™æ€æ–‡ä»¶<CR><NL>import os<CR><NL>media_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "media")<CR><NL>app.mount("/media", StaticFiles(directory=media_dir), name="media")<CR><NL><CR><NL><CR><NL><CR><NL>def transform_coze_result(coze_data):<CR><NL>    '''å°† Coze API è¿”å›çš„é¢˜ç›®åˆ—è¡¨æ ‡å‡†åŒ–ä¸ºå‰ç«¯éœ€è¦çš„ç»“æ„'''<CR><NL>    if not isinstance(coze_data, list):<CR><NL>        return []<CR><NL><CR><NL>    normalized = []<CR><NL>    for item in coze_data:<CR><NL>        # å¤„ç†åµŒå¥—ç»“æ„ï¼šå¦‚æœitemåŒ…å«outputå­—æ®µï¼Œåˆ™æå–å…¶ä¸­çš„questions<CR><NL>        if isinstance(item, dict) and "output" in item and isinstance(item["output"], list):<CR><NL>            for output_item in item["output"]:<CR><NL>                if isinstance(output_item, dict) and "questions" in output_item and isinstance(output_item["questions"], list):<CR><NL>                    for question in output_item["questions"]:<CR><NL>                        normalized_item = {<CR><NL>                            "id": output_item.get("id", ""),<CR><NL>                            "subject": output_item.get("subject") or "",  # æå–å­¦ç§‘å­—æ®µ<CR><NL>                            "section": output_item.get("section") or "",<CR><NL>                            "question": question.get("question") or "",<CR><NL>                            "answer": question.get("answer") or "",<CR><NL>                            "is_question": bool(question.get("is_question", True)),<CR><NL>                            "is_correct": bool(question.get("is_correct", False)),<CR><NL>                            "correct_answer": question.get("correct_answer") or "",<CR><NL>                            "comment": question.get("comment") or "",<CR><NL>                            "error_type": None,<CR><NL>                            "knowledge_point": ", ".join(output_item.get("knowledge_points", [])) if output_item.get("knowledge_points") else None<CR><NL>                        }<CR><NL>                        normalized.append(normalized_item)<CR><NL>        else:<CR><NL>            # å¤„ç†æ™®é€šç»“æ„<CR><NL>            normalized_item = {<CR><NL>                "id": str(item.get("id", "")),<CR><NL>                "subject": item.get("subject") or "",  # æå–å­¦ç§‘å­—æ®µ<CR><NL>                "section": item.get("section") or "",<CR><NL>                "question": item.get("question") or "",<CR><NL>                "answer": item.get("answer") or "",<CR><NL>                "is_question": bool(item.get("is_question", True)),<CR><NL>                "is_correct": bool(item.get("is_correct", False)),<CR><NL>                "correct_answer": item.get("correct_answer") or "",<CR><NL>                "comment": item.get("comment") or "",<CR><NL>            }<CR><NL><CR><NL>            for key, value in item.items():<CR><NL>                if key not in normalized_item:<CR><NL>                    normalized_item[key] = value<CR><NL><CR><NL>            normalized.append(normalized_item)<CR><NL><CR><NL>    return normalized<CR><NL><CR><NL><CR><NL><CR><NL>def extract_practices_from_payload(data):<CR><NL>    """ä» Coze è¿”å›ä¸­æå– practices åˆ—è¡¨ã€‚<CR><NL>    å…¼å®¹é¡¶å±‚/åµŒå¥— output èŠ‚ç‚¹ä¸¤ç§ç»“æ„ã€‚<CR><NL>    """<CR><NL>    practices = []<CR><NL><CR><NL>    def normalize(p):<CR><NL>        return {<CR><NL>            "question": (p or {}).get("question") or "",<CR><NL>            "correct_answer": (p or {}).get("correct_answer") or "",<CR><NL>            "comment": (p or {}).get("comment") or "",<CR><NL>        }<CR><NL><CR><NL>    def collect_from_obj(obj):<CR><NL>        if not isinstance(obj, dict):<CR><NL>            return<CR><NL>        if isinstance(obj.get("practices"), list):<CR><NL>            for p in obj["practices"]:<CR><NL>                if isinstance(p, dict):<CR><NL>                    practices.append(normalize(p))<CR><NL>        # éå† output èŠ‚ç‚¹<CR><NL>        outs = obj.get("output")<CR><NL>        if isinstance(outs, list):<CR><NL>            for out in outs:<CR><NL>                if isinstance(out, dict) and isinstance(out.get("practices"), list):<CR><NL>                    for p in out["practices"]:<CR><NL>                        if isinstance(p, dict):<CR><NL>                            practices.append(normalize(p))<CR><NL><CR><NL>    if isinstance(data, list):<CR><NL>        for item in data:<CR><NL>            if isinstance(item, dict):<CR><NL>                collect_from_obj(item)<CR><NL>    elif isinstance(data, dict):<CR><NL>        collect_from_obj(data)<CR><NL>        # å¸¸è§åµŒå¥—è½½è· data/items/records ç­‰<CR><NL>        for key in ("data", "items", "records", "result", "payload"):<CR><NL>            v = data.get(key)<CR><NL>            if isinstance(v, (list, dict)):<CR><NL>                practices.extend(extract_practices_from_payload(v))<CR><NL><CR><NL>    return practices<CR><NL><CR><NL><CR><NL>async def call_coze_workflow(image_data: bytes, filename: Optional[str] = None) -> dict:<CR><NL>    """è°ƒç”¨ Coze å·¥ä½œæµè¿›è¡Œå›¾åƒåˆ†æï¼ˆéæµå¼ /v1/workflow/run)<CR><NL>    ä¾èµ–ç¯å¢ƒå˜é‡ï¼š<CR><NL>      - COZE_API_HOST          ï¼ˆå¯é€‰ï¼Œé»˜è®¤ api.coze.cnï¼›è‹¥ token æ¥è‡ª coze.comï¼Œè¯·è®¾ä¸º api.coze.comï¼‰<CR><NL>      - COZE_ACCESS_TOKEN æˆ– COZE_API_KEY  ï¼ˆäºŒé€‰ä¸€ï¼Œå»ºè®®å‰è€…ï¼›å¿…é¡»ï¼‰<CR><NL>      - COZE_WORKFLOW_ID       ï¼ˆå¿…é¡»ï¼›å·¥ä½œæµå·²å‘å¸ƒï¼‰<CR><NL>      - COZE_BOT_ID            ï¼ˆå¯é€‰ï¼›æŸäº›å·¥ä½œæµéœ€è¦ï¼‰<CR><NL>      - COZE_APP_ID            ï¼ˆå¯é€‰ï¼›ä¸ BOT_ID äºŒé€‰ä¸€ä¼ ï¼Œä¸è¦éƒ½ä¼ ï¼‰<CR><NL>    """<CR><NL>    import json<CR><NL><CR><NL>    from fastapi import HTTPException<CR><NL><CR><NL>    try:<CR><NL>        from cozepy import AsyncCoze<CR><NL>        from cozepy.auth import AsyncTokenAuth<CR><NL>        from cozepy.config import COZE_CN_BASE_URL, COZE_COM_BASE_URL<CR><NL>        from cozepy.exception import CozeAPIError<CR><NL>    except ImportError as exc:  # SDK æœªå®‰è£…æˆ–ç‰ˆæœ¬è¿‡æ—§<CR><NL>        logger.error("[Coze] cozepy SDK æœªå®‰è£…: %s", exc)<CR><NL>        raise HTTPException(status_code=500, detail="Coze SDK æœªå®‰è£…ï¼Œè¯·æ‰§è¡Œ `pip install cozepy`.") from exc<CR><NL><CR><NL>    # === è¯»å–é…ç½® ===<CR><NL>    coze_host = os.getenv("COZE_API_HOST", "api.coze.cn").strip()<CR><NL>    coze_token = (os.getenv("COZE_ACCESS_TOKEN") or os.getenv("COZE_API_KEY") or "").strip()<CR><NL>    coze_workflow_id = os.getenv("COZE_WORKFLOW_ID", "").strip()<CR><NL>    coze_bot_id = os.getenv("COZE_BOT_ID", "").strip()<CR><NL>    coze_app_id = os.getenv("COZE_APP_ID", "").strip()<CR><NL><CR><NL>    # === é…ç½®æ ¡éªŒ/å›é€€ ===<CR><NL>    if not coze_token or not coze_workflow_id:<CR><NL>        logger.info("Coze é…ç½®ç¼ºå¤±ï¼ˆtoken æˆ– workflow_idï¼‰ï¼Œè¿”å›æ¨¡æ‹Ÿæ•°æ®ä»¥ä¾¿å‰ç«¯è”è°ƒã€‚")<CR><NL>        mock_coze_data = [<CR><NL>            {<CR><NL>                "id": "1.1",<CR><NL>                "subject": "æ•°å­¦",  # æ·»åŠ å­¦ç§‘å­—æ®µ<CR><NL>                "section": "è®¡ç®—é¢˜",<CR><NL>                "question": "è®¡ç®—ï¼š1/2 + 1/3 = ?",<CR><NL>                "answer": "",<CR><NL>                "is_question": True,<CR><NL>                "is_correct": False,<CR><NL>                "correct_answer": "5/6",<CR><NL>                "comment": "éœ€è¦å…ˆæ‰¾åˆ°å…¬åˆ†æ¯ï¼š2å’Œ3çš„æœ€å°å…¬å€æ•°æ˜¯6ï¼Œå°†åˆ†æ•°è½¬æ¢ä¸ºåŒåˆ†æ¯ï¼š1/2 = 3/6ï¼Œ1/3 = 2/6ï¼Œç„¶åç›¸åŠ ï¼š3/6 + 2/6 = 5/6",<CR><NL>            }<CR><NL>        ]<CR><NL>        return {"analysis": transform_coze_result(mock_coze_data), "practices": []}<CR><NL><CR><NL>    coze_workflow_id = coze_workflow_id.strip()<CR><NL>    masked_token = coze_token[:6] + "****" if len(coze_token) >= 10 else "****"<CR><NL><CR><NL>    normalized_host = coze_host.lower().strip()<CR><NL>    normalized_host = normalized_host.replace("https://", "").replace("http://", "").strip("/")<CR><NL>    if normalized_host.endswith("coze.cn"):<CR><NL>        base_url = COZE_CN_BASE_URL<CR><NL>    elif normalized_host.endswith("coze.com"):<CR><NL>        base_url = COZE_COM_BASE_URL<CR><NL>    else:<CR><NL>        base_url = f"https://{normalized_host}"<CR><NL><CR><NL>    logger.info(<CR><NL>        "[Coze] host=%s, workflow_id='%s', token(head)=%s, bot_id=%s, app_id=%s, base_url=%s",<CR><NL>        coze_host,<CR><NL>        coze_workflow_id,<CR><NL>        masked_token,<CR><NL>        "SET" if coze_bot_id else "NONE",<CR><NL>        "SET" if coze_app_id else "NONE",<CR><NL>        base_url,<CR><NL>    )<CR><NL><CR><NL>    file_name = filename or f"mistake-note-{uuid.uuid4().hex}.png"<CR><NL>    upload_buffer = io.BytesIO(image_data)<CR><NL>    upload_buffer.name = file_name<CR><NL>    upload_buffer.seek(0)<CR><NL><CR><NL>    coze_client = AsyncCoze(auth=AsyncTokenAuth(token=coze_token), base_url=base_url)<CR><NL><CR><NL>    try:<CR><NL>        uploaded_file = await coze_client.files.upload(file=upload_buffer)<CR><NL>        logger.info("[Coze] æ–‡ä»¶ä¸Šä¼ æˆåŠŸï¼Œfile_id=%s, size=%d", uploaded_file.id, len(image_data))<CR><NL>    except CozeAPIError as exc:<CR><NL>        error_message = f"Coze æ–‡ä»¶ä¸Šä¼ å¤±è´¥ï¼šcode={exc.code}, msg={exc.msg}, logid={exc.logid}"<CR><NL>        logger.error("[Coze] %s", error_message)<CR><NL>        raise HTTPException(status_code=502, detail=error_message) from exc<CR><NL>    except Exception as exc:<CR><NL>        logger.error("[Coze] æ–‡ä»¶ä¸Šä¼ å¼‚å¸¸: %s", exc)<CR><NL>        raise HTTPException(status_code=500, detail=f"æ— æ³•ä¸Šä¼ æ–‡ä»¶è‡³ Cozeï¼š{exc}") from exc<CR><NL>    finally:<CR><NL>        upload_buffer.close()<CR><NL><CR><NL>    input_param_key = os.getenv("COZE_INPUT_PARAM_KEY", "input").strip() or "input"<CR><NL>    nested_file_param = os.getenv("COZE_IMAGE_FILE_FIELD", "file_id").strip() or "file_id"<CR><NL><CR><NL>    parameters = {<CR><NL>        "analyze_type": "math_error_analysis",<CR><NL>    }<CR><NL>    parameters[input_param_key] = {<CR><NL>        nested_file_param: uploaded_file.id,<CR><NL>    }<CR><NL><CR><NL>    if coze_bot_id and coze_app_id:<CR><NL>        logger.warning("[Coze] BOT_ID ä¸ APP_ID åŒæ—¶å­˜åœ¨ï¼ŒæŒ‰çº¦å®šä¼˜å…ˆä½¿ç”¨ BOT_IDã€‚")<CR><NL>        coze_app_id = ""<CR><NL><CR><NL>    safe_dbg = {<CR><NL>        "workflow_id": coze_workflow_id,<CR><NL>        "has_bot_id": bool(coze_bot_id),<CR><NL>        "has_app_id": bool(coze_app_id),<CR><NL>        "file_id": uploaded_file.id,<CR><NL>        "input_param_key": input_param_key,<CR><NL>        "nested_file_param": nested_file_param,<CR><NL>        "image_bytes": len(image_data),<CR><NL>        "parameters": {input_param_key: parameters.get(input_param_key)},<CR><NL>    }<CR><NL>    logger.info("[Coze] è¯·æ±‚æ‘˜è¦: %s", json.dumps(safe_dbg, ensure_ascii=False))<CR><NL><CR><NL>    try:<CR><NL>        result = await coze_client.workflows.runs.create(<CR><NL>            workflow_id=coze_workflow_id,<CR><NL>            parameters=parameters,<CR><NL>            bot_id=coze_bot_id or None,<CR><NL>            app_id=coze_app_id or None,<CR><NL>        )<CR><NL>    except CozeAPIError as exc:<CR><NL>        error_message = f"Coze SDK è°ƒç”¨å¤±è´¥ï¼šcode={exc.code}, msg={exc.msg}, logid={exc.logid}"<CR><NL>        logger.error("[Coze] %s", error_message)<CR><NL>        raise HTTPException(status_code=502, detail=error_message) from exc<CR><NL>    except Exception as exc:<CR><NL>        logger.error("[Coze] è°ƒç”¨ /workflow/run å¤±è´¥: %s", exc)<CR><NL>        raise HTTPException(status_code=500, detail=f"æ— æ³•è°ƒç”¨ Coze å·¥ä½œæµï¼š{exc}") from exc<CR><NL><CR><NL>    if result.debug_url:<CR><NL>        logger.info("[Coze] debug_url=%s", result.debug_url)<CR><NL><CR><NL>    raw_payload = result.data or ""<CR><NL>    logger.info("[Coze] å®Œæ•´å“åº”: %s", raw_payload)<CR><NL>    if not raw_payload.strip():<CR><NL>        logger.error("[Coze] å·¥ä½œæµè¿”å›ä¸ºç©ºã€‚")<CR><NL>        raise HTTPException(status_code=502, detail="Coze æœªè¿”å›ä»»ä½•æ•°æ®ï¼Œè¯·æ£€æŸ¥å·¥ä½œæµè¾“å‡ºã€‚")<CR><NL><CR><NL>    try:<CR><NL>        parsed_payload = json.loads(raw_payload)<CR><NL>        logger.info("[Coze] æˆåŠŸè§£æå·¥ä½œæµè¿”å›ï¼Œé•¿åº¦=%d", len(raw_payload))<CR><NL>    except json.JSONDecodeError:<CR><NL>        logger.error("[Coze] å·¥ä½œæµè¿”å›é JSONï¼Œç¤ºä¾‹=%s", raw_payload[:200])<CR><NL>        raise HTTPException(status_code=502, detail="Coze è¿”å›å†…å®¹æ— æ³•è§£æï¼Œè¯·æ£€æŸ¥å·¥ä½œæµè¾“å‡ºã€‚")<CR><NL><CR><NL>    if isinstance(parsed_payload, dict) and "data" in parsed_payload:<CR><NL>        coze_payload = parsed_payload.get("data")<CR><NL>    else:<CR><NL>        coze_payload = parsed_payload<CR><NL><CR><NL>    logger.info("[Coze] è½¬æ¢å‰æ•°æ®ç±»å‹: %s", type(coze_payload).__name__)<CR><NL><CR><NL><CR><NL><CR><NL>    practices = extract_practices_from_payload(coze_payload)<CR><NL><CR><NL>    if isinstance(coze_payload, list):<CR><NL><CR><NL>        transformed = transform_coze_result(coze_payload)<CR><NL><CR><NL>        logger.info("[Coze] è½¬æ¢åæ•°æ®: %s", json.dumps(transformed, ensure_ascii=False))<CR><NL><CR><NL>        return {"analysis": transformed, "practices": practices}<CR><NL><CR><NL><CR><NL><CR><NL>    if isinstance(coze_payload, dict):<CR><NL><CR><NL>        logger.info("[Coze] è¿”å› dict æ•°æ®: %s", json.dumps(coze_payload, ensure_ascii=False))<CR><NL><CR><NL>        nested_candidates = []<CR><NL><CR><NL>        for key in ("data", "items", "records", "questions"):<CR><NL><CR><NL>            value = coze_payload.get(key) if isinstance(coze_payload, dict) else None<CR><NL><CR><NL>            if isinstance(value, list):<CR><NL><CR><NL>                nested_candidates = value<CR><NL><CR><NL>                break<CR><NL><CR><NL><CR><NL><CR><NL>        if nested_candidates:<CR><NL><CR><NL>            transformed = transform_coze_result(nested_candidates)<CR><NL><CR><NL>            logger.info("[Coze] åµŒå¥—åˆ—è¡¨è½¬æ¢åæ•°æ®: %s", json.dumps(transformed, ensure_ascii=False))<CR><NL><CR><NL>            return {"analysis": transformed, "practices": practices}<CR><NL><CR><NL><CR><NL><CR><NL>        transformed = transform_coze_result([coze_payload])<CR><NL><CR><NL>        logger.info("[Coze] å•æ¡æ•°æ®è½¬æ¢åæ•°æ®: %s", json.dumps(transformed, ensure_ascii=False))<CR><NL><CR><NL>        return {"analysis": transformed, "practices": practices}<CR><NL><CR><NL><CR><NL><CR><NL>    logger.error("[Coze] è¿”å›æ•°æ®ç±»å‹ %s æš‚ä¸æ”¯æŒ", type(coze_payload).__name__)<CR><NL><CR><NL>    raise HTTPException(status_code=502, detail="Coze è¿”å›æ•°æ®æ ¼å¼ä¸æ”¯æŒï¼Œè¯·æ£€æŸ¥å·¥ä½œæµè¾“å‡ºã€‚")<CR><NL><CR><NL><CR><NL><CR><NL>@app.get("/")<CR><NL><CR><NL>def read_root():<CR><NL><CR><NL>    missing_keys = []<CR><NL><CR><NL>    for key in ["BAIDU_OCR_API_KEY", "BAIDU_ASR_API_KEY", "BAIDU_TTS_API_KEY", "LLM_API_KEY", "COZE_API_KEY", "COZE_WORKFLOW_ID"]:<CR><NL><CR><NL>        if not os.getenv(key):<CR><NL><CR><NL>            missing_keys.append(key)<CR><NL><CR><NL>    if missing_keys:<CR><NL><CR><NL>        return {"status": "warning", "missing_keys": missing_keys}<CR><NL><CR><NL>    return {"status": "ok", "message": "mistake_note API is running."}<CR><NL><CR><NL><CR><NL><CR><NL>@app.post("/upload/image")<CR><NL><CR><NL>async def upload_image(image: UploadFile = File(...)):<CR><NL><CR><NL>    """ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶å¹¶è¿›è¡Œå¤„ç†"""<CR><NL><CR><NL>    <CR><NL><CR><NL>    # éªŒè¯æ–‡ä»¶æ ¼å¼<CR><NL><CR><NL>    allowed_extensions = {'.jpg', '.jpeg', '.png', '.pdf'}<CR><NL><CR><NL>    file_extension = os.path.splitext(image.filename)[1].lower()<CR><NL><CR><NL>    <CR><NL><CR><NL>    if file_extension not in allowed_extensions:<CR><NL><CR><NL>        raise HTTPException(<CR><NL><CR><NL>            status_code=400, <CR><NL><CR><NL>            detail=f"ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ã€‚æ”¯æŒæ ¼å¼: {', '.join(allowed_extensions)}"<CR><NL><CR><NL>        )<CR><NL><CR><NL>    <CR><NL><CR><NL>    # éªŒè¯æ–‡ä»¶å¤§å°ï¼ˆæœ€å¤§10MBï¼‰<CR><NL><CR><NL>    max_size = 10 * 1024 * 1024  # 10MB<CR><NL><CR><NL>    content = await image.read()<CR><NL><CR><NL>    if len(content) > max_size:<CR><NL><CR><NL>        raise HTTPException(<CR><NL><CR><NL>            status_code=400,<CR><NL><CR><NL>            detail=f"æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶ã€‚æœ€å¤§æ”¯æŒ: {max_size // (1024*1024)}MB"<CR><NL><CR><NL>        )<CR><NL><CR><NL>    <CR><NL><CR><NL>    # ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å<CR><NL><CR><NL>    file_id = str(uuid.uuid4())<CR><NL><CR><NL>    filename = f"{file_id}{file_extension}"<CR><NL><CR><NL>    file_path = os.path.join("../media", "uploads", filename)<CR><NL><CR><NL>    <CR><NL><CR><NL>    # ä¿å­˜æ–‡ä»¶<CR><NL><CR><NL>    with open(file_path, "wb") as f:<CR><NL><CR><NL>        f.write(content)<CR><NL><CR><NL>    <CR><NL><CR><NL>    # è°ƒç”¨Coze APIè¿›è¡Œåˆ†æ<CR><NL><CR><NL>    try:<CR><NL><CR><NL>        coze_result = await call_coze_workflow(content, image.filename)<CR><NL><CR><NL>    except HTTPException:<CR><NL><CR><NL>        # å¦‚æœCoze APIè°ƒç”¨å¤±è´¥ï¼Œè¿”å›åŸºæœ¬çš„ä¸Šä¼ ä¿¡æ¯<CR><NL><CR><NL>        coze_result = None<CR><NL><CR><NL>    if coze_result is None:<CR><NL>        coze_result = {"analysis": [], "practices": []}<CR><NL><CR><NL>    if isinstance(coze_result, list):<CR><NL>        coze_result = {"analysis": coze_result, "practices": []}<CR><NL><CR><NL>    coze_analysis = coze_result.get("analysis", [])<CR><NL>    practices = coze_result.get("practices", [])<CR><NL><CR><NL>    # è¿”å›å¤„ç†ç»“æœ<CR><NL><CR><NL>    result = {<CR><NL><CR><NL>        "status": "success",<CR><NL><CR><NL>        "message": "å›¾ç‰‡ä¸Šä¼ æˆåŠŸ",<CR><NL><CR><NL>        "file_id": file_id,<CR><NL><CR><NL>        "filename": filename,<CR><NL><CR><NL>        "file_url": f"/media/uploads/{filename}",<CR><NL><CR><NL>        "upload_time": datetime.now().isoformat(),<CR><NL><CR><NL>        "file_size": len(content),<CR><NL><CR><NL>        "file_type": image.content_type<CR><NL><CR><NL>    }<CR><NL><CR><NL>    <CR><NL><CR><NL>    result["coze_analysis"] = coze_analysis<CR><NL>    if practices:<CR><NL>        result["practices"] = practices<CR><NL><CR><NL>    # ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“<CR><NL><CR><NL>    if DATABASE_AVAILABLE and coze_analysis:<CR><NL><CR><NL>        try:<CR><NL><CR><NL>            logger.info(f"å¼€å§‹ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“ï¼Œæ–‡ä»¶ID: {file_id}")<CR><NL><CR><NL>            logger.info(f"æ–‡ä»¶ä¿¡æ¯: filename={filename}, size={len(content)}, type={image.content_type}")<CR><NL><CR><NL>            logger.info(f"Cozeåˆ†ææ•°æ®: {json.dumps(coze_analysis, ensure_ascii=False)}")<CR><NL><CR><NL>            <CR><NL><CR><NL>            db = next(get_db())<CR><NL><CR><NL>            record_id = save_mistake_record(db, result, coze_analysis, practices)<CR><NL><CR><NL>            logger.info(f"âœ… æ•°æ®ä¿å­˜æˆåŠŸï¼é”™é¢˜è®°å½•ID: {record_id}, æ–‡ä»¶ID: {file_id}")<CR><NL><CR><NL>            logger.info(f"âœ… ä¿å­˜äº† {len(coze_analysis)} æ¡åˆ†æè®°å½•")<CR><NL><CR><NL>            <CR><NL><CR><NL>        except Exception as e:<CR><NL><CR><NL>            logger.error(f"âŒ ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“å¤±è´¥: {e}")<CR><NL><CR><NL>            logger.error(f"âŒ é”™è¯¯è¯¦æƒ…: {str(e)}")<CR><NL><CR><NL>    else:<CR><NL><CR><NL>        if not DATABASE_AVAILABLE:<CR><NL><CR><NL>            logger.warning("âš ï¸ æ•°æ®åº“ä¸å¯ç”¨ï¼Œæ•°æ®æœªä¿å­˜")<CR><NL><CR><NL>        elif not coze_analysis:<CR><NL><CR><NL>            logger.info("â„¹ï¸ æ²¡æœ‰åˆ†ææ•°æ®ï¼Œè·³è¿‡æ•°æ®åº“ä¿å­˜")<CR><NL><CR><NL>    return result<CR><NL><CR><NL><CR><NL><CR><NL>@app.post("/analyze/image")<CR><NL><CR><NL>async def analyze_image(image: UploadFile = File(...)):<CR><NL><CR><NL>    """ç›´æ¥åˆ†æå›¾ç‰‡ï¼Œä¹Ÿä¿å­˜åˆ°æ•°æ®åº“"""<CR><NL><CR><NL>    <CR><NL><CR><NL>    # éªŒè¯æ–‡ä»¶æ ¼å¼<CR><NL><CR><NL>    allowed_extensions = {'.jpg', '.jpeg', '.png', '.pdf'}<CR><NL><CR><NL>    file_extension = os.path.splitext(image.filename)[1].lower()<CR><NL><CR><NL>    <CR><NL><CR><NL>    if file_extension not in allowed_extensions:<CR><NL><CR><NL>        raise HTTPException(<CR><NL><CR><NL>            status_code=400, <CR><NL><CR><NL>            detail=f"ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ã€‚æ”¯æŒæ ¼å¼: {', '.join(allowed_extensions)}"<CR><NL><CR><NL>        )<CR><NL><CR><NL>    <CR><NL><CR><NL>    # éªŒè¯æ–‡ä»¶å¤§å°ï¼ˆæœ€å¤§10MBï¼‰<CR><NL><CR><NL>    max_size = 10 * 1024 * 1024  # 10MB<CR><NL><CR><NL>    content = await image.read()<CR><NL><CR><NL>    if len(content) > max_size:<CR><NL><CR><NL>        raise HTTPException(<CR><NL><CR><NL>            status_code=400,<CR><NL><CR><NL>            detail=f"æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶ã€‚æœ€å¤§æ”¯æŒ: {max_size // (1024*1024)}MB"<CR><NL><CR><NL>        )<CR><NL><CR><NL>    <CR><NL><CR><NL>    # è°ƒç”¨Coze APIè¿›è¡Œåˆ†æ<CR><NL><CR><NL>    coze_result = await call_coze_workflow(content, image.filename)<CR><NL><CR><NL>    # ??? Coze ????,????????????<CR><NL>    if not coze_result:<CR><NL>        coze_result = {"analysis": [], "practices": []}<CR><NL>    elif isinstance(coze_result, list):<CR><NL>        coze_result = {"analysis": coze_result, "practices": []}<CR><NL><CR><NL>    coze_analysis = coze_result.get("analysis", [])<CR><NL>    practices = coze_result.get("practices", [])<CR><NL><CR><NL>    # ç”Ÿæˆæ–‡ä»¶ä¿¡æ¯ç”¨äºæ•°æ®åº“ä¿å­˜<CR><NL>    file_id = str(uuid.uuid4())<CR><NL>    filename = f"{file_id}{file_extension}"<CR><NL><CR><NL>    # å‡†å¤‡æ•°æ®åº“ä¿å­˜æ•°æ®<CR><NL>    file_data = {<CR><NL>        "file_id": file_id,<CR><NL>        "filename": filename,<CR><NL>        "file_url": f"/media/uploads/{filename}",<CR><NL>        "file_size": len(content),<CR><NL>        "file_type": image.content_type,<CR><NL>        "upload_time": datetime.now().isoformat()<CR><NL>    }<CR><NL><CR><NL>    # ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“<CR><NL>    if DATABASE_AVAILABLE and coze_analysis:<CR><NL><CR><NL>        try:<CR><NL><CR><NL>            logger.info(f"ğŸ“ [analyze/image] å¼€å§‹ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“ï¼Œæ–‡ä»¶ID: {file_id}")<CR><NL><CR><NL>            logger.info(f"ğŸ“ [analyze/image] æ–‡ä»¶ä¿¡æ¯: filename={filename}, size={len(content)}, type={image.content_type}")<CR><NL><CR><NL>            logger.info(f"ğŸ“Š [analyze/image] Cozeåˆ†ææ•°æ®: {json.dumps(coze_analysis, ensure_ascii=False)}")<CR><NL><CR><NL>            <CR><NL><CR><NL>            db = next(get_db())<CR><NL><CR><NL>            record_id = save_mistake_record(db, file_data, coze_analysis, practices)<CR><NL><CR><NL>            logger.info(f"âœ… [analyze/image] æ•°æ®ä¿å­˜æˆåŠŸï¼é”™é¢˜è®°å½•ID: {record_id}, æ–‡ä»¶ID: {file_id}")<CR><NL><CR><NL>            logger.info(f"âœ… [analyze/image] ä¿å­˜äº† {len(coze_analysis)} æ¡åˆ†æè®°å½•")<CR><NL><CR><NL>            <CR><NL><CR><NL>        except Exception as e:<CR><NL><CR><NL>            logger.error(f"âŒ [analyze/image] ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“å¤±è´¥: {e}")<CR><NL><CR><NL>            logger.error(f"âŒ [analyze/image] é”™è¯¯è¯¦æƒ…: {str(e)}")<CR><NL><CR><NL>    else:<CR><NL><CR><NL>        if not DATABASE_AVAILABLE:<CR><NL><CR><NL>            logger.warning("âš ï¸ [analyze/image] æ•°æ®åº“ä¸å¯ç”¨ï¼Œæ•°æ®æœªä¿å­˜")<CR><NL><CR><NL>        elif not coze_analysis:<CR><NL><CR><NL>            logger.info("â„¹ï¸ [analyze/image] æ²¡æœ‰åˆ†ææ•°æ®ï¼Œè·³è¿‡æ•°æ®åº“ä¿å­˜")<CR><NL><CR><NL><CR><NL>    # æ„å»ºå“åº”æ•°æ®<CR><NL>    response_data = {<CR><NL>        "status": "success",<CR><NL>        "message": "å›¾ç‰‡åˆ†æå®Œæˆ",<CR><NL>        "analysis": coze_analysis,<CR><NL>        "analyze_time": datetime.now().isoformat()<CR><NL>    }<CR><NL>    <CR><NL>    # å¦‚æœä¿å­˜åˆ°æ•°æ®åº“æˆåŠŸï¼Œæ·»åŠ é”™é¢˜è®°å½•ID<CR><NL>    if DATABASE_AVAILABLE and coze_analysis:<CR><NL>        response_data["mistake_record_id"] = record_id<CR><NL>    <NL>    # ??????????(analyze ??)<NL>    try:<NL>        for p in practices_data:<NL>            response_data["practices"].append({<NL>                "id": getattr(p, "id", None),<NL>                "question": getattr(p, "question", None),<NL>                "correct_answer": getattr(p, "correct_answer", None),<NL>                "comment": getattr(p, "comment", None),<NL>                "created_at": p.created_at.isoformat() if getattr(p, "created_at", None) else None,<NL>            })<NL>    except Exception:<NL>        pass<NL><NL>    return response_data<NL><CR><NL><CR><NL>@app.get("/mistake/{mistake_id}")<CR><NL>async def get_mistake_detail(mistake_id: int):<CR><NL>    """æŸ¥è¯¢é”™é¢˜è¯¦æƒ…<CR><NL>    å‚æ•°: mistake_id - é”™é¢˜è®°å½•ä¸»é”®ID<CR><NL>    è¿”å›: é”™é¢˜è¯¦æƒ…ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ–‡ä»¶ä¿¡æ¯å’Œåˆ†æç»“æœ<CR><NL>    """<CR><NL>    if not DATABASE_AVAILABLE:<CR><NL>        raise HTTPException(<CR><NL>            status_code=503,<CR><NL>            detail="æ•°æ®åº“ä¸å¯ç”¨ï¼Œæ— æ³•æŸ¥è¯¢é”™é¢˜è¯¦æƒ…"<CR><NL>        )<CR><NL>    <CR><NL>    try:<CR><NL>        db = next(get_db())<CR><NL>        <CR><NL>        # æ ¹æ®ä¸»é”®IDæŸ¥è¯¢é”™é¢˜è®°å½•<CR><NL>        mistake_record = db.query(MistakeRecord).filter(MistakeRecord.id == mistake_id).first()<CR><NL>        <CR><NL>        if not mistake_record:<CR><NL>            raise HTTPException(<CR><NL>                status_code=404,<CR><NL>                detail=f"æœªæ‰¾åˆ°IDä¸º {mistake_id} çš„é”™é¢˜è®°å½•"<CR><NL>            )<CR><NL>        <CR><NL>        # æŸ¥è¯¢ç›¸å…³çš„åˆ†æè®°å½•<CR><NL>        analysis_data = db.query(MistakeAnalysis).filter(MistakeAnalysis.mistake_record_id == mistake_id).all()<CR><NL>        practices_data = db.query(MistakePractice).filter(MistakePractice.mistake_record_id == mistake_id).all()<CR><NL>        <CR><NL>        # æ„å»ºå“åº”æ•°æ®<CR><NL>        response_data = {<CR><NL>            "file_info": {<CR><NL>                "id": mistake_record.id,<CR><NL>                "file_id": mistake_record.file_id,<CR><NL>                "filename": mistake_record.filename,<CR><NL>                "file_url": mistake_record.file_url,<CR><NL>                "file_size": mistake_record.file_size,<CR><NL>                "file_type": mistake_record.file_type,<CR><NL>                "upload_time": mistake_record.upload_time.isoformat() if mistake_record.upload_time else None,<CR><NL>                "created_at": mistake_record.created_at.isoformat() if mistake_record.created_at else None<CR><NL>            },<CR><NL>            "analysis": [],`n            "practices": []<CR><NL>        }<CR><NL>        <CR><NL>        # æ·»åŠ æ‰€æœ‰åˆ†æè®°å½•<CR><NL>        for analysis in analysis_data:<CR><NL>            # å¦‚æœä¸»è¦å­—æ®µä¸ºç©ºä½†analysis_dataå­—æ®µæœ‰æ•°æ®ï¼Œåˆ™ä»analysis_dataä¸­æå–<CR><NL>            if (not analysis.section and not analysis.question and not analysis.answer and <CR><NL>                analysis.analysis_data and isinstance(analysis.analysis_data, dict)):<CR><NL>                <CR><NL>                analysis_data_dict = analysis.analysis_data<CR><NL>                # å¤„ç†åµŒå¥—ç»“æ„<CR><NL>                if "output" in analysis_data_dict and isinstance(analysis_data_dict["output"], list):<CR><NL>                    for output_item in analysis_data_dict["output"]:<CR><NL>                        if isinstance(output_item, dict) and "questions" in output_item and isinstance(output_item["questions"], list):<CR><NL>                            for question in output_item["questions"]:<CR><NL>                                analysis_item = {<CR><NL>                                    "id": output_item.get("id", ""),<CR><NL>                                    "section": output_item.get("section") or "",<CR><NL>                                    "question": question.get("question") or "",<CR><NL>                                    "answer": question.get("answer") or "",<CR><NL>                                    "is_question": bool(question.get("is_question", True)),<CR><NL>                                    "is_correct": bool(question.get("is_correct", False)),<CR><NL>                                    "correct_answer": question.get("correct_answer") or "",<CR><NL>                                    "comment": question.get("comment") or "",<CR><NL>                                    "error_type": None,<CR><NL>                                    "knowledge_point": ", ".join(output_item.get("knowledge_points", [])) if output_item.get("knowledge_points") else None,<CR><NL>                                    "created_at": analysis.created_at.isoformat() if analysis.created_at else None<CR><NL>                                }<CR><NL>                                response_data["analysis"].append(analysis_item)<CR><NL>            else:<CR><NL>                # ä½¿ç”¨æ­£å¸¸çš„å­—æ®µæ•°æ®<CR><NL>                analysis_item = {<CR><NL>                    "id": analysis.id,<CR><NL>                    "section": analysis.section,<CR><NL>                    "question": analysis.question,<CR><NL>                    "answer": analysis.answer,<CR><NL>                    "is_question": analysis.is_question,<CR><NL>                    "is_correct": analysis.is_correct,<CR><NL>                    "correct_answer": analysis.correct_answer,<CR><NL>                    "comment": analysis.comment,<CR><NL>                    "error_type": analysis.error_type,<CR><NL>                    "knowledge_point": analysis.knowledge_point,<CR><NL>                    "created_at": analysis.created_at.isoformat() if analysis.created_at else None<CR><NL>                }<CR><NL>                response_data["analysis"].append(analysis_item)<CR><NL>        <CR><NL>        logger.info(f"âœ… æˆåŠŸæŸ¥è¯¢é”™é¢˜è¯¦æƒ…ï¼Œè®°å½•ID: {mistake_id}, åˆ†æè®°å½•æ•°: {len(response_data['analysis'])}")<CR><NL>                        # ???????<CR><NL>        try:<CR><NL>            for p in practices_data:<CR><NL>                response_data["practices"].append({<CR><NL>                    "id": getattr(p, "id", None),<CR><NL>                    "question": getattr(p, "question", None),<CR><NL>                    "correct_answer": getattr(p, "correct_answer", None),<CR><NL>                    "comment": getattr(p, "comment", None),<CR><NL>                    "created_at": p.created_at.isoformat() if getattr(p, "created_at", None) else None,<CR><NL>                })<CR><NL>        except Exception:\r\n            pass\r\n\r\n    return response_data<CR><NL>        <CR><NL>    except HTTPException:<CR><NL>        raise<CR><NL>    except Exception as e:<CR><NL>        logger.error(f"âŒ æŸ¥è¯¢é”™é¢˜è¯¦æƒ…å¤±è´¥: {e}")<CR><NL>        raise HTTPException(<CR><NL>            status_code=500,<CR><NL>            detail=f"æŸ¥è¯¢é”™é¢˜è¯¦æƒ…æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}"<CR><NL>        )<CR><NL><CR><NL><CR><NL>@app.get("/mistakes")<CR><NL>async def get_mistakes_list(<CR><NL>    subject: str = None,<CR><NL>    error_type: str = None,<CR><NL>    knowledge_point: str = None,<CR><NL>    skip: int = 0,<CR><NL>    limit: int = 100<CR><NL>):<CR><NL>    """é”™é¢˜æœ¬ä¸€è§ˆæŸ¥è¯¢API<CR><NL>    æ”¯æŒæŒ‰å­¦ç§‘ã€æŒ‰é”™è¯¯åŸå› ã€æŒ‰çŸ¥è¯†ç‚¹æŸ¥è¯¢ï¼ˆçŸ¥è¯†ç‚¹æ”¯æŒæ¨¡ç³ŠæŸ¥è¯¢ï¼‰<CR><NL>    <CR><NL>    å‚æ•°:<CR><NL>    - subject: å­¦ç§‘ï¼ˆå¦‚ï¼šæ•°å­¦ã€ç‰©ç†ã€åŒ–å­¦ç­‰ï¼‰<CR><NL>    - error_type: é”™è¯¯ç±»å‹ï¼ˆå¦‚ï¼šè®¡ç®—é”™è¯¯ã€æ¦‚å¿µä¸æ¸…ç­‰ï¼‰<CR><NL>    - knowledge_point: çŸ¥è¯†ç‚¹ï¼ˆæ”¯æŒæ¨¡ç³ŠæŸ¥è¯¢ï¼‰<CR><NL>    - skip: è·³è¿‡çš„è®°å½•æ•°ï¼ˆåˆ†é¡µç”¨ï¼‰<CR><NL>    - limit: è¿”å›çš„æœ€å¤§è®°å½•æ•°ï¼ˆåˆ†é¡µç”¨ï¼‰<CR><NL>    <CR><NL>    è¿”å›: é”™é¢˜åˆ—è¡¨ï¼ŒåŒ…å«æ–‡ä»¶ä¿¡æ¯å’Œåˆ†æç»“æœ<CR><NL>    """<CR><NL>    if not DATABASE_AVAILABLE:<CR><NL>        raise HTTPException(<CR><NL>            status_code=503,<CR><NL>            detail="æ•°æ®åº“ä¸å¯ç”¨ï¼Œæ— æ³•æŸ¥è¯¢é”™é¢˜åˆ—è¡¨"<CR><NL>        )<CR><NL>    <CR><NL>    try:<CR><NL>        db = next(get_db())<CR><NL>        <CR><NL>        # æ„å»ºæŸ¥è¯¢<CR><NL>        query = db.query(MistakeAnalysis).join(MistakeRecord)<CR><NL>        <CR><NL>        # æŒ‰å­¦ç§‘æŸ¥è¯¢<CR><NL>        if subject:<CR><NL>            query = query.filter(MistakeAnalysis.subject == subject)<CR><NL>        <CR><NL>        # æŒ‰é”™è¯¯ç±»å‹æŸ¥è¯¢<CR><NL>        if error_type:<CR><NL>            query = query.filter(MistakeAnalysis.error_type == error_type)<CR><NL>        <CR><NL>        # æŒ‰çŸ¥è¯†ç‚¹æŸ¥è¯¢ï¼ˆæ”¯æŒæ¨¡ç³ŠæŸ¥è¯¢ï¼‰<CR><NL>        if knowledge_point:<CR><NL>            query = query.filter(MistakeAnalysis.knowledge_point.ilike(f"%{knowledge_point}%"))<CR><NL>        <CR><NL>        # åº”ç”¨åˆ†é¡µ<CR><NL>        total_count = query.count()<CR><NL>        analysis_data = query.offset(skip).limit(limit).all()<CR><NL>        <CR><NL>        # æ„å»ºå“åº”æ•°æ®<CR><NL>        response_data = {<CR><NL>            "total_count": total_count,<CR><NL>            "skip": skip,<CR><NL>            "limit": limit,<CR><NL>            "mistakes": []<CR><NL>        }<CR><NL>        <CR><NL>        # æ·»åŠ æ‰€æœ‰é”™é¢˜è®°å½•<CR><NL>        for analysis in analysis_data:<CR><NL>            mistake_record = analysis.mistake_record<CR><NL>            <CR><NL>            # æ„å»ºé”™é¢˜é¡¹<CR><NL>            mistake_item = {<CR><NL>                "mistake_record_id": mistake_record.id,<CR><NL>                "file_info": {<CR><NL>                    "file_id": mistake_record.file_id,<CR><NL>                    "filename": mistake_record.filename,<CR><NL>                    "file_url": mistake_record.file_url,<CR><NL>                    "file_size": mistake_record.file_size,<CR><NL>                    "file_type": mistake_record.file_type,<CR><NL>                    "upload_time": mistake_record.upload_time.isoformat() if mistake_record.upload_time else None,<CR><NL>                    "created_at": mistake_record.created_at.isoformat() if mistake_record.created_at else None<CR><NL>                },<CR><NL>                "analysis": {<CR><NL>                    "id": analysis.id,<CR><NL>                    "subject": analysis.subject,<CR><NL>                    "section": analysis.section,<CR><NL>                    "question": analysis.question,<CR><NL>                    "answer": analysis.answer,<CR><NL>                    "is_question": analysis.is_question,<CR><NL>                    "is_correct": analysis.is_correct,<CR><NL>                    "correct_answer": analysis.correct_answer,<CR><NL>                    "comment": analysis.comment,<CR><NL>                    "error_type": analysis.error_type,<CR><NL>                    "knowledge_point": analysis.knowledge_point,<CR><NL>                    "created_at": analysis.created_at.isoformat() if analysis.created_at else None<CR><NL>                }<CR><NL>            }<CR><NL>            response_data["mistakes"].append(mistake_item)<CR><NL>        <CR><NL>        logger.info(f"âœ… æˆåŠŸæŸ¥è¯¢é”™é¢˜åˆ—è¡¨ï¼Œæ€»æ•°: {total_count}, è¿”å›: {len(response_data['mistakes'])} æ¡è®°å½•")<CR><NL>        logger.info(f"âœ… æŸ¥è¯¢æ¡ä»¶: subject={subject}, error_type={error_type}, knowledge_point={knowledge_point}")<CR><NL>        <CR><NL>                        # ???????<CR><NL>        try:<CR><NL>            for p in practices_data:<CR><NL>                response_data["practices"].append({<CR><NL>                    "id": getattr(p, "id", None),<CR><NL>                    "question": getattr(p, "question", None),<CR><NL>                    "correct_answer": getattr(p, "correct_answer", None),<CR><NL>                    "comment": getattr(p, "comment", None),<CR><NL>                    "created_at": p.created_at.isoformat() if getattr(p, "created_at", None) else None,<CR><NL>                })<CR><NL>        except Exception:\r\n            pass\r\n\r\n    return response_data<CR><NL>        <CR><NL>    except HTTPException:<CR><NL>        raise<CR><NL>    except Exception as e:<CR><NL>        logger.error(f"âŒ æŸ¥è¯¢é”™é¢˜åˆ—è¡¨å¤±è´¥: {e}")<CR><NL>        raise HTTPException(<CR><NL>            status_code=500,<CR><NL>            detail=f"æŸ¥è¯¢é”™é¢˜åˆ—è¡¨æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}"<CR><NL>        )<CR><NL><CR><NL><CR><NL><CR><NL><CR><NL><CR><NL><CR><NL>
